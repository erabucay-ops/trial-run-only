<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Spatial Decision Simulator (DEM + Weighted Suitability)</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>

  <!-- Turf for distance-to-line calculations -->
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <style>
:root {
      --bg: #0b0f14;
      --panel: rgba(20, 26, 34, 0.92);
      --text: #e7eef7;
      --muted: #a9b7c6;
      --accent: #5dd6ff;
      --border: rgba(255,255,255,0.12);
      --shadow: rgba(0,0,0,0.35);
    }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji"; }
    #app { height: 100vh; height: 100dvh; display: grid; grid-template-columns: 380px 1fr; }
    #map { height: 100%; width: 100%; min-height: 45vh; }

    .panel {
      padding: 14px 14px 12px;
      background: var(--panel);
      border-right: 1px solid var(--border);
      box-shadow: 0 10px 25px var(--shadow);
      overflow: auto;
    }
    .title { font-size: 16px; font-weight: 700; letter-spacing: 0.2px; margin: 2px 0 10px; }
    .sub { font-size: 12px; color: var(--muted); line-height: 1.35; margin-bottom: 12px; }

    .card {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      margin: 10px 0;
      background: rgba(255,255,255,0.03);
    }

    .row { display: flex; gap: 10px; align-items: center; }
    .row > * { flex: 1; }
    label { font-size: 12px; color: var(--muted); display: block; margin-bottom: 6px; }
    input[type="range"] { width: 100%; }
    .kpi { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .kpi .box {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px;
      background: rgba(255,255,255,0.02);
    }
    .kpi .v { font-size: 16px; font-weight: 700; margin-top: 4px; }
    .kpi .t { font-size: 11px; color: var(--muted); }

    .status {
      display: flex;
      gap: 10px;
      align-items: center;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.02);
      margin-top: 10px;
    }
    .dot { width: 12px; height: 12px; border-radius: 999px; background: #999; box-shadow: 0 0 0 3px rgba(255,255,255,0.06) inset; }
    .status .big { font-weight: 800; }
    .status .small { font-size: 12px; color: var(--muted); margin-top: 2px; }

    .btnrow { display: flex; gap: 10px; }
    button {
      flex: 1;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.04);
      color: var(--text);
      padding: 10px 10px;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 650;
    }
    button:hover { border-color: rgba(255,255,255,0.25); }
    button:active { transform: translateY(1px); }

    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .warn { color: #ffd27a; }
    .ok { color: #8dffb5; }
    .bad { color: #ff8aa6; }

    .foot { font-size: 11px; color: var(--muted); line-height: 1.35; margin-top: 10px; }
    .foot a { color: var(--accent); text-decoration: none; }
    .foot a:hover { text-decoration: underline; }

    @media (max-width: 900px) {
#app { grid-template-columns: 1fr; grid-template-rows: auto 1fr; 
  .panel { border-right: none; border-bottom: 1px solid var(--border); max-height: 45vh; overflow: auto; }

  #map { min-height: 55vh; }
}

      .panel { border-right: none; border-bottom: 1px solid var(--border); }
    }
</style>
</head>
<body>
<div id="app">
  <div class="panel">
    <div class="title">Spatial Decision Simulator</div>
    <div class="sub">
      Tap/click anywhere in <b><span id="provName">Laguna</span> Province</b> to evaluate site suitability using:
      <b>real elevation tiles</b> (terrain-based slope), distance to <b>rivers/creeks</b>, and distance to <b>roads</b>.
      Designed for in-class discussion and spatial reasoning.
    </div>

    <div class="card">
      <div style="font-weight:700; margin-bottom:8px;">Select Province</div>
      <div class="row" style="margin-bottom:10px;">
        <div style="flex:1.4;">
          <label>Province (Philippines)</label>
          <select id="provinceSelect" style="width:100%; padding:10px; border-radius:12px; border:1px solid var(--border); background: rgba(255,255,255,0.04); color: var(--text);">
          </select>
        </div>
        <div style="flex:1;">
          <label>&nbsp;</label>
          <button id="btnProvince">Zoom to Province</button>
        </div>
      </div>
      <div class="foot" id="provMsg">Tip: switch provinces to compare how terrain + access changes suitability.</div>
    </div>


    <div class="card">
      <div style="font-weight:700; margin-bottom:8px;">Modes</div>

      <div class="row" style="margin-bottom:10px;">
        <div style="flex:1.4;">
          <label>Scenario</label>
          <select id="scenarioSelect" style="width:100%; padding:10px; border-radius:12px; border:1px solid var(--border); background: rgba(255,255,255,0.04); color: var(--text);">
            <option value="housing">Housing</option>
            <option value="evac"> Center</option>
            <option value="school">School</option>
          </select>
        </div>
        <div style="flex:1;">
          <label>Class Mode</label>
          <div style="display:flex; gap:10px; align-items:center; padding:10px; border-radius:12px; border:1px solid var(--border); background: rgba(255,255,255,0.02);">
            <input id="classMode" type="checkbox" checked style="transform: scale(1.2);"/>
            <span class="mono" id="cooldownInfo">Cooldown: 2s</span>
          </div>
        </div>
      </div>

      <div class="btnrow">
        <button id="btnApplyScenario">Apply Scenario Defaults</button>
        <button id="btnToggleBlock">Block Outside Province: ON</button>
      </div>

      <div class="row" style="margin-top:10px;">
        <div style="flex:1;">
          <label>Exclude wetlands (teaching toggle)</label>
          <div style="display:flex; gap:10px; align-items:center; padding:10px; border-radius:12px; border:1px solid var(--border); background: rgba(255,255,255,0.02);">
            <input id="excludeWetlands" type="checkbox" />
            <span class="mono">Exclude natural=wetland</span>
          </div>
        </div>
      </div>

      <div class="foot" id="clipWarn" style="margin-top:10px;"></div>
    </div>


    <div class="card">
      <div class="btnrow">
        <button id="btnLaguna" style="display:none;">Zoom to Laguna</button>
        <button id="btnExplain">What does this mean?</button>
      </div>
      <div class="foot" id="msg"></div>
    </div>

    <div class="card">
      <div style="font-weight:700; margin-bottom:8px;">Weighted scoring (map algebra)</div>

      <div class="row" style="margin-bottom:10px;">
        <div>
          <label>Slope weight</label>
          <input id="wSlope" type="range" min="0" max="100" value="50" />
          <div class="mono" id="wSlopeV">0.50</div>
        </div>
        <div>
          <label>River risk weight</label>
          <input id="wRiver" type="range" min="0" max="100" value="30" />
          <div class="mono" id="wRiverV">0.30</div>
        </div>
        <div>
          <label>Road access weight</label>
          <input id="wRoad" type="range" min="0" max="100" value="20" />
          <div class="mono" id="wRoadV">0.20</div>
        </div>
      </div>

      <div class="row" style="margin-bottom:10px;">
        <div>
          <label>River “safe distance” (m)</label>
          <input id="riverSafe" type="range" min="50" max="500" value="150" step="10"/>
          <div class="mono" id="riverSafeV">150 m</div>
        </div>
        <div>
          <label>Road “max walkable” (m)</label>
          <input id="roadMax" type="range" min="100" max="1500" value="500" step="50"/>
          <div class="mono" id="roadMaxV">500 m</div>
        </div>
        <div>
          <label>Max “tolerable slope” (°)</label>
          <input id="slopeMax" type="range" min="5" max="45" value="20" step="1"/>
          <div class="mono" id="slopeMaxV">20°</div>
        </div>
      </div>

      <div class="foot">
        Question: how does changing weights changes the suitability of an area? e.g. equity vs safety vs access
      </div>
    </div>

    <div class="card">
      <div style="font-weight:700; margin-bottom:8px;">Results at selected point</div>

      <div class="kpi">
        <div class="box">
          <div class="t">Slope (°)</div>
          <div class="v mono" id="kSlope">—</div>
        </div>
        <div class="box">
          <div class="t">Elevation (m)</div>
          <div class="v mono" id="kElev">—</div>
        </div>
        <div class="box">
          <div class="t">Dist. to river (m)</div>
          <div class="v mono" id="kRiver">—</div>
        </div>
        <div class="box">
          <div class="t">Dist. to road (m)</div>
          <div class="v mono" id="kRoad">—</div>
        </div>
      </div>

      <div class="status">
        <div class="dot" id="dot"></div>
        <div style="flex:1;">
          <div class="big" id="kClass">—</div>
          <div class="small" id="kWhy">Tap the map to evaluate a location.</div>
        </div>
        <div class="mono" style="font-weight:800;" id="kScore">—</div>
      </div>

      <div class="foot" style="margin-top:10px;">
        Note: Rivers, lakes/reservoirs, and roads are queried live from OpenStreetMap via the Overpass API (internet required).
        Elevation is queried from public “Terrarium” elevation tiles (internet required).
        Water bodies are treated as a hard exclusion (score = 0 if you click inside water). Wetlands can be optionally excluded via the teaching toggle.
      </div>
    </div>

    <div class="card">
      <div style="font-weight:700; margin-bottom:8px;">Guide Questions</div>
      <div class="sub" style="margin:0;">
        1) “Would you site <b>housing</b> here? Why?”<br/>
        2) “Would you site <b>school</b> here? Why?”<br/>
        3) “Would this be a good <b>evacuation center</b> site? Why?”<br/>
        4) “Which weight matters most for <b>low-income</b> communities? Safety, access, or proximity to water?”<br/>
      </div>
    </div>

    <div class="foot">
      
    </div>
  </div>

  <div id="map"></div>
</div>

<script>
/* =========================
   Map init (Philippines + selected province)
   ========================= */
const phBBox = { south: 4.5, west: 116.9, north: 21.2, east: 126.6 }; // broad PH extent
let currentProvince = "Laguna";

const map = L.map('map', {
  zoomControl: true,
  preferCanvas: true
}).setView([12.5, 121.7], 6);

const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19,
  attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);

// Simple relief-ish overlay (optional)
const hillshade = L.tileLayer('https://tiles.wmflabs.org/hillshading/{z}/{x}/{y}.png', {
  maxZoom: 17,
  opacity: 0.35,
  attribution: 'Hillshade: Wikimedia Labs'
}).addTo(map);

// Mobile/Safari: ensure Leaflet recalculates map size after layout/orientation changes
function invalidateMapSize() {
  setTimeout(() => { try { map.invalidateSize(true); } catch (e) {} }, 250);
}
window.addEventListener('resize', invalidateMapSize);
window.addEventListener('orientationchange', invalidateMapSize);

let marker = null;
let lagunaBoundaryLayer = null;
let lastClickLatLng = null;

// Mode state
let isEvaluating = false;
let lastEvalTs = 0;
const CLASS_COOLDOWN_MS = 2000;
let blockOutsideProvince = true;

// Province geometry for clip warning (GeoJSON Feature)
let currentProvinceGeoJSON = null;

/* =========================
   UI elements
   ========================= */
const el = (id) => document.getElementById(id);
const msg = el('msg');

const sliders = {
  wSlope: el('wSlope'),
  wRiver: el('wRiver'),
  wRoad:  el('wRoad'),
  riverSafe: el('riverSafe'),
  roadMax: el('roadMax'),
  slopeMax: el('slopeMax'),
};

function setSliderLabels() {
  const ws = parseFloat(sliders.wSlope.value) / 100;
  const wr = parseFloat(sliders.wRiver.value) / 100;
  const wd = parseFloat(sliders.wRoad.value) / 100;
  el('wSlopeV').textContent = ws.toFixed(2);
  el('wRiverV').textContent = wr.toFixed(2);
  el('wRoadV').textContent  = wd.toFixed(2);

  el('riverSafeV').textContent = `${sliders.riverSafe.value} m`;
  el('roadMaxV').textContent   = `${sliders.roadMax.value} m`;
  el('slopeMaxV').textContent  = `${sliders.slopeMax.value}°`;
}
Object.values(sliders).forEach(s => s.addEventListener('input', () => {
  setSliderLabels();
  if (lastClickLatLng) evaluatePoint(lastClickLatLng);
}));

// =========================
// Scenario presets
// =========================
const SCENARIOS = {
  housing: {
    label: "Housing",
    weights: { slope: 40, river: 40, road: 20 },
    thresholds: { slopeMax: 18, riverSafe: 150, roadMax: 600 }
  },
  evac: {
    label: "Evacuation Center",
    weights: { slope: 50, river: 40, road: 10 },
    thresholds: { slopeMax: 15, riverSafe: 250, roadMax: 900 }
  },
  school: {
    label: "School",
    weights: { slope: 20, river: 20, road: 60 },
    thresholds: { slopeMax: 20, riverSafe: 120, roadMax: 400 }
  }
};

function applyScenario(key) {
  const s = SCENARIOS[key] || SCENARIOS.housing;

  sliders.wSlope.value = s.weights.slope;
  sliders.wRiver.value = s.weights.river;
  sliders.wRoad.value  = s.weights.road;

  sliders.slopeMax.value = s.thresholds.slopeMax;
  sliders.riverSafe.value = s.thresholds.riverSafe;
  sliders.roadMax.value = s.thresholds.roadMax;

  setSliderLabels();

  const cw = el('clipWarn');
  if (cw) cw.innerHTML = `<span class="ok">Scenario applied:</span> <b>${s.label}</b>.`;
}

// Wire Mode UI
(function wireModes() {
  const scenarioSelect = el('scenarioSelect');
  const btnApply = el('btnApplyScenario');
  const btnToggle = el('btnToggleBlock');
  const cooldownInfo = el('cooldownInfo');

  if (cooldownInfo) cooldownInfo.textContent = `Cooldown: ${Math.round(CLASS_COOLDOWN_MS/1000)}s`;

  if (btnToggle) {
    btnToggle.addEventListener('click', () => {
      blockOutsideProvince = !blockOutsideProvince;
      btnToggle.textContent = `Block Outside Province: ${blockOutsideProvince ? 'ON' : 'OFF'}`;
      const cw = el('clipWarn');
      if (cw) cw.innerHTML = blockOutsideProvince
        ? `<span class="ok">Outside clicks blocked</span> when Class Mode is ON.`
        : `<span class="warn">Outside clicks allowed</span> (warning only).`;
    });
  }

  if (btnApply && scenarioSelect) {
    btnApply.addEventListener('click', () => applyScenario(scenarioSelect.value));
  }
  if (scenarioSelect) {
    scenarioSelect.addEventListener('change', () => applyScenario(scenarioSelect.value));
    // default
    applyScenario(scenarioSelect.value);
  }
})();


setSliderLabels();

/* =========================
   Helpers: geo + scoring
   ========================= */

function clamp01(x){ return Math.max(0, Math.min(1, x)); }

function classifySuitability(suit) {
  // suit: 0..1 higher is better
  if (suit >= 0.75) return {label: 'SUITABLE', dot:'#32d47a'};
  if (suit >= 0.55) return {label: 'MODERATE', dot:'#ffd56a'};
  return {label: 'HIGH RISK', dot:'#ff6d8f'};
}

function haversineMeters(a, b) {
  const R = 6371000;
  const toRad = (d) => d * Math.PI / 180;
  const dLat = toRad(b.lat - a.lat);
  const dLon = toRad(b.lng - a.lng);
  const lat1 = toRad(a.lat), lat2 = toRad(b.lat);
  const s = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
  return 2*R*Math.asin(Math.sqrt(s));
}

/* =========================
   Elevation tiles (Terrarium)
   =========================
   Tile source encodes elevation:
   elevation(m) = (R * 256 + G + B / 256) - 32768
*/
const TERRARIUM = 'https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{z}/{x}/{y}.png';
const tileCache = new Map();

function tileKey(z,x,y){ return `${z}/${x}/${y}`; }

function lngLatToTileXY(lat, lng, z) {
  const n = Math.pow(2, z);
  const xtile = Math.floor((lng + 180) / 360 * n);
  const latRad = lat * Math.PI / 180;
  const ytile = Math.floor((1 - Math.log(Math.tan(latRad) + 1/Math.cos(latRad)) / Math.PI) / 2 * n);
  return {x: xtile, y: ytile};
}

function tileXYToLngLat(x, y, z) {
  const n = Math.pow(2, z);
  const lng = x / n * 360 - 180;
  const latRad = Math.atan(Math.sinh(Math.PI * (1 - 2*y/n)));
  const lat = latRad * 180 / Math.PI;
  return {lat, lng};
}

async function loadTerrariumTile(z, x, y) {
  const key = tileKey(z,x,y);
  if (tileCache.has(key)) return tileCache.get(key);

  const url = TERRARIUM.replace('{z}', z).replace('{x}', x).replace('{y}', y);
  const img = new Image();
  img.crossOrigin = 'anonymous';

  const p = new Promise((resolve, reject) => {
    img.onload = () => {
      const canvas = document.createElement('canvas');
      canvas.width = img.width;
      canvas.height = img.height;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      ctx.drawImage(img, 0, 0);
      resolve({canvas, ctx, w: img.width, h: img.height});
    };
    img.onerror = (e) => reject(new Error('Failed to load elevation tile (CORS or network).'));
  });

  img.src = url;
  const tile = await p;
  tileCache.set(key, tile);
  return tile;
}

function elevationFromRGB(r,g,b) {
  return (r * 256 + g + b / 256) - 32768;
}

async function getElevationAt(lat, lng, z) {
  // sample at z (best results around z=12-14)
  const {x, y} = lngLatToTileXY(lat, lng, z);
  const tile = await loadTerrariumTile(z, x, y);

  // pixel coords inside tile
  const n = Math.pow(2, z);
  const px = ((lng + 180) / 360 * n - x) * tile.w;
  const latRad = lat * Math.PI / 180;
  const py = ((1 - Math.log(Math.tan(latRad) + 1/Math.cos(latRad)) / Math.PI) / 2 * n - y) * tile.h;

  const ix = Math.max(0, Math.min(tile.w-1, Math.floor(px)));
  const iy = Math.max(0, Math.min(tile.h-1, Math.floor(py)));

  const data = tile.ctx.getImageData(ix, iy, 1, 1).data;
  return elevationFromRGB(data[0], data[1], data[2]);
}

async function getSlopeDegrees(lat, lng, z) {
  // Horn-style estimate using 3x3 around pixel.
  // We approximate ground resolution using meters-per-pixel at this latitude.
  const {x, y} = lngLatToTileXY(lat, lng, z);
  const tile = await loadTerrariumTile(z, x, y);

  const n = Math.pow(2, z);
  const px = ((lng + 180) / 360 * n - x) * tile.w;
  const latRad = lat * Math.PI / 180;
  const py = ((1 - Math.log(Math.tan(latRad) + 1/Math.cos(latRad)) / Math.PI) / 2 * n - y) * tile.h;

  const cx = Math.max(1, Math.min(tile.w-2, Math.floor(px)));
  const cy = Math.max(1, Math.min(tile.h-2, Math.floor(py)));

  const sample = (dx, dy) => {
    const data = tile.ctx.getImageData(cx + dx, cy + dy, 1, 1).data;
    return elevationFromRGB(data[0], data[1], data[2]);
  };

  const z1 = sample(-1,-1), z2 = sample(0,-1), z3 = sample(1,-1);
  const z4 = sample(-1, 0), z5 = sample(0, 0), z6 = sample(1, 0);
  const z7 = sample(-1, 1), z8 = sample(0, 1), z9 = sample(1, 1);

  // meters per pixel at this latitude (approx WebMercator)
  const earthCirc = 40075016.686; // meters
  const mPerPixel = (earthCirc * Math.cos(latRad)) / (tile.w * n);

  // Horn derivatives
  const dzdx = ((z3 + 2*z6 + z9) - (z1 + 2*z4 + z7)) / (8 * mPerPixel);
  const dzdy = ((z7 + 2*z8 + z9) - (z1 + 2*z2 + z3)) / (8 * mPerPixel);

  const slopeRad = Math.atan(Math.sqrt(dzdx*dzdx + dzdy*dzdy));
  return { slopeDeg: slopeRad * 180/Math.PI, elev: z5 };
}

/* =========================
   Overpass: roads + rivers
   ========================= */
// Overpass endpoints (failover). 429 = rate-limited; we automatically try the next endpoint.
const OVERPASS_ENDPOINTS = [
  'https://overpass-api.de/api/interpreter',
  'https://overpass.kumi.systems/api/interpreter',
  'https://overpass.openstreetmap.ru/api/interpreter'
];

// Throttle + cache to avoid hammering Overpass during rapid classroom clicking
const OVERPASS_MIN_INTERVAL_MS = 1200;   // cooldown between Overpass calls
const OSM_CACHE_TTL_MS = 10 * 60 * 1000; // 10 minutes
let _lastOverpassCallTs = 0;
const _osmCache = new Map(); // key -> {ts, data}

function _cacheKey(lat, lng, zoom) {
  // ~100-150m grid (3 decimals ~111m lat). Include zoom bucket to avoid mixing scales.
  const latK = lat.toFixed(3);
  const lngK = lng.toFixed(3);
  const zK = Math.max(6, Math.min(14, Math.round(zoom)));
  return `${latK},${lngK},z${zK}`;
}

async function overpassQuery(query) {
  // Use GET (not POST) to reduce CORS/preflight issues on mobile Safari and some networks.
  // Failover across endpoints; handle 429 with backoff.
  const encoded = encodeURIComponent(query);
  let lastErr = null;

  for (let i = 0; i < OVERPASS_ENDPOINTS.length; i++) {
    const endpoint = OVERPASS_ENDPOINTS[i];
    const url = `${endpoint}?data=${encoded}`;

    try {
      _lastOverpassCallTs = Date.now();

      const res = await fetch(url, {
        method: 'GET',
        headers: { 'Accept': 'application/json' }
      });

      if (res.status === 429) {
        lastErr = new Error(`Overpass rate-limited (429) at ${endpoint}`);
        await new Promise(r => setTimeout(r, 900 + i * 400));
        continue;
      }
      if (res.status >= 500) {
        lastErr = new Error(`Overpass server error (${res.status}) at ${endpoint}`);
        await new Promise(r => setTimeout(r, 700 + i * 300));
        continue;
      }
      if (!res.ok) {
        lastErr = new Error(`Overpass API error: ${res.status} at ${endpoint}`);
        await new Promise(r => setTimeout(r, 400 + i * 200));
        continue;
      }
      return await res.json();
    } catch (e) {
      lastErr = e;
      await new Promise(r => setTimeout(r, 500 + i * 250));
      continue;
    }
  }

  throw new Error(
    'Overpass is busy or blocked on this network. ' +
    'Try again in 10–30 seconds, or switch networks. ' +
    (lastErr ? ` Last error: ${lastErr.message || lastErr}` : '')
  );
}


// Lightweight containment check using Overpass 'is_in'.
// This catches huge water bodies (Laguna Lake, Taal Lake, seas) without downloading full polygon geometry.
const _isInCache = new Map(); // key -> {ts, data}
const ISIN_CACHE_TTL_MS = 10 * 60 * 1000;

async function overpassIsInWaterWetland(lat, lng) {
  const zoom = map.getZoom();
  const key = _cacheKey(lat, lng, zoom) + "|isin";
  const now = Date.now();

  const cached = _isInCache.get(key);
  if (cached && (now - cached.ts) < ISIN_CACHE_TTL_MS) return cached.data;

  // Define explicit water= values to match
  const waterRe = "lake|reservoir|pond|lagoon|basin|river|canal|stream|salt|oxbow|ditch|wetland";

  const q = `
  [out:json][timeout:18];
  is_in(${lat},${lng})->.a;
  (
    area.a["natural"="water"];
    area.a["water"~"${waterRe}"];
    area.a["waterway"="riverbank"];
    area.a["landuse"="reservoir"];
    area.a["natural"="wetland"];
  );
  out tags;`;

  let json = null;
  try {
    json = await overpassQuery(q);
  } catch (e) {
    // If is_in fails, return unknown rather than breaking evaluation.
    const data = { inWater: false, inWetland: false, seasonal: false, matchedTags: [] };
    _isInCache.set(key, { ts: now, data });
    return data;
  }

  let inWater = false, inWetland = false, seasonal = false;
  const matchedTags = [];

  for (const el of (json.elements || [])) {
    const t = el.tags || {};
    if (String(t.intermittent || "").toLowerCase() === "yes") seasonal = true;

    const isWet = (t.natural === "wetland");
    const isWat = (t.natural === "water") || (t.landuse === "reservoir") || (t.waterway === "riverbank") || (t.water && new RegExp(`^(${waterRe})$`, "i").test(String(t.water)));

    if (isWet) inWetland = true;
    if (isWat) inWater = true;

    if (isWet || isWat) matchedTags.push(t);
  }

  const data = { inWater, inWetland, seasonal, matchedTags };
  _isInCache.set(key, { ts: now, data });
  return data;
}

// Admin containment check (Philippines + selected province) using Overpass is_in.
// This is more reliable than local polygon member geometry for some provinces.
const _adminIsInCache = new Map(); // key -> {ts, data}
const ADMIN_ISIN_CACHE_TTL_MS = 10 * 60 * 1000;

async function overpassIsInPHAndProvince(lat, lng, provinceName) {
  const zoom = map.getZoom();
  const key = _cacheKey(lat, lng, zoom) + "|admin|" + String(provinceName || "");
  const now = Date.now();

  const cached = _adminIsInCache.get(key);
  if (cached && (now - cached.ts) < ADMIN_ISIN_CACHE_TTL_MS) return cached.data;

  // Note: In OSM, national/provincial admin boundaries generally follow the coastline (land),
  // so points in the open sea typically return no PH/province areas.
  const q = `
  [out:json][timeout:18];
  is_in(${lat},${lng})->.a;
  (
    area.a["ISO3166-1"="PH"];
    area.a["boundary"="administrative"]["admin_level"="4"]["name"="${provinceName}"];
  );
  out tags;`;

  try {
    const json = await overpassQuery(q);
    let inPH = false, inProvince = false;
    for (const el of (json.elements || [])) {
      const t = el.tags || {};
      if (t["ISO3166-1"] === "PH") inPH = true;
      if (t.boundary === "administrative" && t.admin_level === "4" && t.name === provinceName) inProvince = true;
    }
    const data = { inPH, inProvince };
    _adminIsInCache.set(key, { ts: now, data });
    return data;
  } catch (e) {
    // If Overpass busy, fail open for PH/province checks (don't block class)
    const data = { inPH: true, inProvince: true, uncertain: true };
    _adminIsInCache.set(key, { ts: now, data });
    return data;
  }
}


function osmToLineFeatures(osmJson) {
  // Convert Overpass "ways" with geometry to GeoJSON LineString features (turf)
  const features = [];
  for (const el of osmJson.elements || []) {
    if (el.type === 'way' && el.geometry && el.geometry.length >= 2) {
      const coords = el.geometry.map(g => [g.lon, g.lat]);
      features.push(turf.lineString(coords, el.tags || {}));
    }
  }
  return features;
}

function osmToPolygonFeatures(osmJson) {
  // Convert closed Overpass "ways" (with geometry) to GeoJSON Polygon features (turf)
  const features = [];
  for (const el of osmJson.elements || []) {
    if (el.type === 'way' && el.geometry && el.geometry.length >= 4) {
      const coords = el.geometry.map(g => [g.lon, g.lat]);
      const first = coords[0], last = coords[coords.length - 1];
      const isClosed = first[0] === last[0] && first[1] === last[1];
      if (!isClosed) continue;

      // Simple polygon ring
      try {
        features.push(turf.polygon([coords], el.tags || {}));
      } catch (e) {
        // ignore invalid polygons
      }
    }
  }
  return features;
}

function pointInAnyPolygon(pt, polys) {
  for (const p of polys) {
    try {
      if (turf.booleanPointInPolygon(pt, p)) return true;
    } catch (e) {}
  }
  return false;
}

function osmRelationsToPolygonFeatures(osmJson) {
  // Convert Overpass relations with member geometries to Polygon features (turf).
  // We use only 'outer' rings when available.
  const features = [];
  for (const el of osmJson.elements || []) {
    if (el.type !== 'relation' || !el.members) continue;

    const outers = [];
    for (const mem of el.members) {
      if (!mem.geometry || mem.geometry.length < 4) continue;
      if (mem.role && mem.role !== 'outer') continue;

      const coords = mem.geometry.map(g => [g.lon, g.lat]);
      const first = coords[0], last = coords[coords.length - 1];
      if (first[0] !== last[0] || first[1] !== last[1]) coords.push(first);

      // ensure ring has enough distinct points
      if (coords.length >= 4) outers.push(coords);
    }

    for (const ring of outers) {
      try {
        features.push(turf.polygon([ring], el.tags || {}));
      } catch (e) {}
    }
  }
  return features;
}

function minDistanceMetersToLines(pt, lineFeatures) {
  if (!lineFeatures.length) return null;
  let min = Infinity;
  for (const lf of lineFeatures) {
    const d = turf.pointToLineDistance(pt, lf, {units:'kilometers'}) * 1000;
    if (d < min) min = d;
  }
  return min;
}

async function getDistancesToOSM(lat, lng) {
  // Cache per grid cell to drastically reduce Overpass calls in class
  const zoom = map.getZoom();
  const key = _cacheKey(lat, lng, zoom);
  const now = Date.now();

  const cached = _osmCache.get(key);
  if (cached && (now - cached.ts) < OSM_CACHE_TTL_MS) {
    return cached.data;
  }

  // Query radius: smaller radius = fewer features = fewer bytes = less chance of 429/timeouts
  // Use slightly larger radius when zoomed out.
  const R = (zoom <= 8) ? 3500 : (zoom <= 10 ? 2500 : 1800);

  // Filter to common planning-relevant road classes and waterway types
  const q = `
  [out:json][timeout:18];
  (
    way(around:${R},${lat},${lng})["waterway"~"river|stream|canal|drain"];
    way(around:${R},${lat},${lng})["natural"="water"];
    way(around:${R},${lat},${lng})["natural"="wetland"];
    way(around:${R},${lat},${lng})["landuse"="reservoir"];
    relation(around:${R},${lat},${lng})["natural"="water"];
    relation(around:${R},${lat},${lng})["natural"="wetland"];
    relation(around:${R},${lat},${lng})["landuse"="reservoir"];
    way(around:${R},${lat},${lng})["waterway"="riverbank"];
    relation(around:${R},${lat},${lng})["waterway"="riverbank"];
    way(around:${R},${lat},${lng})["highway"~"motorway|trunk|primary|secondary|tertiary|residential|unclassified|service"];
  );
  out geom;`;

  const json = await overpassQuery(q);

  const pt = turf.point([lng, lat]);
  const ways = (json.elements || []).filter(e => e.type === 'way' && e.geometry);

  const rivers = osmToLineFeatures({elements: ways.filter(w => (w.tags && (w.tags.waterway || (w.tags.natural === 'water'))))});
  const roads  = osmToLineFeatures({elements: ways.filter(w => (w.tags && w.tags.highway))});
  
  const WATER_VALUES = new Set(["lake","reservoir","pond","lagoon","basin","river","canal","stream","salt","oxbow","ditch","wetland"]);

  const waterWays = ways.filter(w => (w.tags && (
    w.tags.natural === 'water' ||
    w.tags.landuse === 'reservoir' ||
    w.tags.waterway === 'riverbank' ||
    (w.tags.water && WATER_VALUES.has(String(w.tags.water).toLowerCase()))
  )));

  const wetlandWays = ways.filter(w => (w.tags && w.tags.natural === 'wetland'));

  const rels = (json.elements || []).filter(e => e.type === 'relation' && e.members && e.tags);
  const waterRels = rels.filter(r => (
    r.tags.natural === 'water' ||
    r.tags.landuse === 'reservoir' ||
    r.tags.waterway === 'riverbank' ||
    (r.tags.water && WATER_VALUES.has(String(r.tags.water).toLowerCase()))
  ));

  const wetlandRels = rels.filter(r => (r.tags.natural === 'wetland'));

  const waterPolys = [
    ...osmToPolygonFeatures({elements: waterWays}),
    ...osmRelationsToPolygonFeatures({elements: waterRels})
  ];

  const wetlandPolys = [
    ...osmToPolygonFeatures({elements: wetlandWays}),
    ...osmRelationsToPolygonFeatures({elements: wetlandRels})
  ];

  // Determine if click is in water/wetland polygons
  const isWater = pointInAnyPolygon(pt, waterPolys);
  const isWetland = pointInAnyPolygon(pt, wetlandPolys);

  // Surface intermittent/seasonal if any matching polygon has intermittent=yes
  function anyIntermittent(polys) {
    for (const p of polys) {
      try {
        const tags = p && p.properties ? p.properties : {};
        if (tags && String(tags.intermittent).toLowerCase() === 'yes') return true;
      } catch (e) {}
    }
    return false;
  }
  const isSeasonalWater = anyIntermittent(waterPolys) || anyIntermittent(wetlandPolys);
  const dRiver = minDistanceMetersToLines(pt, rivers);
  const dRoad  = minDistanceMetersToLines(pt, roads);

  const data = { dRiver, dRoad, rivers, roads, waterPolys, isWater, wetlandPolys, isWetland, isSeasonalWater };
  _osmCache.set(key, { ts: now, data });

  return data;
}

/* =========================
   Boundary (Laguna) via Overpass relation
   ========================= */

/* =========================
   Boundary (Laguna) via Overpass relation
   ========================= */
async function loadProvinceBoundary(provName) {
  msg.innerHTML = `<span class="warn">Loading ${provName} boundary…</span>`;
  el('provName').textContent = provName;
  currentProvince = provName;

  try {
    // Constrain search to Philippines to reduce ambiguity
    const q = `
    [out:json][timeout:25];
    area["ISO3166-1"="PH"]->.ph;
    rel(area.ph)["boundary"="administrative"]["admin_level"="4"]["name"="${provName}"];
    out geom;`;

    const json = await overpassQuery(q);

    // Build polygon rings from relation members
    let polys = [];
    for (const relEl of json.elements || []) {
      if (relEl.type === 'relation' && relEl.members) {
        for (const m of relEl.members) {
          if (m.geometry && m.geometry.length >= 3) {
            const coords = m.geometry.map(g => [g.lon, g.lat]);
            if (coords.length && (coords[0][0] !== coords[coords.length-1][0] || coords[0][1] !== coords[coords.length-1][1])) {
              coords.push(coords[0]);
            }
            polys.push(coords);
          }
        }
      }
    }

    if (!polys.length) throw new Error('Boundary geometry not returned by Overpass.');

    const gj = {
      "type":"Feature",
      "properties":{"name":provName},
      "geometry":{
        "type":"MultiPolygon",
        "coordinates": polys.map(ring => [ring])
      }
    };

    currentProvinceGeoJSON = gj;

    if (lagunaBoundaryLayer) map.removeLayer(lagunaBoundaryLayer);
    lagunaBoundaryLayer = L.geoJSON(gj, {
      style: { color: '#5dd6ff', weight: 2, fillOpacity: 0.06 }
    }).addTo(map);

    // Use Leaflet's normalized GeoJSON for point-in-polygon (more robust)
    try {
      currentProvinceGeoJSON = lagunaBoundaryLayer.toGeoJSON();
    } catch (e) {}

    // Zoom to the loaded boundary
    const b = lagunaBoundaryLayer.getBounds();
    map.fitBounds(b, { padding:[14,14] });
    invalidateMapSize();

    msg.innerHTML = `<span class="ok">${provName} boundary loaded.</span>`;
    el('provMsg').innerHTML = `Selected province: <b>${provName}</b>. Click the map to evaluate a site.`;
  } catch (e) {
    // Fallback: zoom to Philippines extent and show error; evaluation can still work anywhere.
    if (lagunaBoundaryLayer) { map.removeLayer(lagunaBoundaryLayer); lagunaBoundaryLayer = null; }
    const bounds = L.latLngBounds([[phBBox.south, phBBox.west],[phBBox.north, phBBox.east]]);
    map.fitBounds(bounds, { padding:[10,10] });
    msg.innerHTML = `<span class="warn">Could not load ${provName} boundary.</span> ${e.message || e}`;
    el('provMsg').innerHTML = `<span class="warn">Boundary not loaded.</span> You can still click anywhere, but the app won't clip to the province.`;
  }
}


/* =========================
   Evaluation pipeline
   ========================= */
function setKPI(id, val, suffix='') {
  el(id).textContent = (val === null || val === undefined || Number.isNaN(val)) ? '—' : `${val}${suffix}`;
}
function setStatus(label, dotColor, score, why) {
  el('kClass').textContent = label;
  el('dot').style.background = dotColor;
  el('kScore').textContent = (score === null ? '—' : score.toFixed(2));
  el('kWhy').textContent = why || '';
}

async function evaluatePoint(latlng) {
  lastClickLatLng = latlng;

  // Class mode: prevent overlapping evaluations
  if (isEvaluating) return;

  // Quick guard: if user clicks far outside PH extent, treat as ocean/outside PH without calling Overpass
  const bboxPad = 4.0; // degrees
  if (latlng.lat < (phBBox.south - bboxPad) || latlng.lat > (phBBox.north + bboxPad) ||
      latlng.lng < (phBBox.west  - bboxPad) || latlng.lng > (phBBox.east  + bboxPad)) {
    const cw = el('clipWarn');
    if (cw) cw.innerHTML = `<span class="warn">Outside Philippines:</span> open sea/ocean point.`;
    setStatus('NOT SUITABLE (OCEAN/SEA)', '#ff6d8f', 0, 'Point is outside the Philippines extent. Choose a land location within the Philippines.');
    return;
  }

  // Land/ocean exclusion + province containment using Overpass is_in (robust for seas and some boundary geometries)
  // If the point is not inside PH admin area, treat it as ocean/outside PH and mark not suitable.
  try {
    const adm = await overpassIsInPHAndProvince(latlng.lat, latlng.lng, currentProvince);
    if (adm && adm.inPH === false) {
      const cw = el('clipWarn');
      if (cw) cw.innerHTML = `<span class="warn">Outside Philippines:</span> open sea/ocean point.`;
      setStatus('NOT SUITABLE (OCEAN/SEA)', '#ff6d8f', 0, 'Point is outside PH land/admin area (OSM). Choose a location on land within the Philippines.');
      return;
    }
  } catch (e) {
    // If admin check fails, continue (non-fatal)
  }

  // Province clip warning / optional block
  try {
    if (currentProvinceGeoJSON) {
      const pt = turf.point([latlng.lng, latlng.lat]);
      let inside = false;
      try {
        // currentProvinceGeoJSON may be a Feature (Polygon/MultiPolygon) OR a FeatureCollection from Leaflet.
      if (currentProvinceGeoJSON && currentProvinceGeoJSON.type === 'FeatureCollection' && Array.isArray(currentProvinceGeoJSON.features)) {
        inside = currentProvinceGeoJSON.features.some(f => {
          try { return turf.booleanPointInPolygon(pt, f); } catch (e) { return false; }
        });
      } else {
        inside = turf.booleanPointInPolygon(pt, currentProvinceGeoJSON);
      }
      } catch (e) { inside = false; }

      // If polygon test says "outside" but boundary is known to be flaky, confirm via Overpass admin containment
      if (!inside) {
        try {
          const adm = await overpassIsInPHAndProvince(latlng.lat, latlng.lng, currentProvince);
          if (adm && adm.inProvince === true) inside = true;
        } catch (e) {}
      }

      const cw = el('clipWarn');
      const classModeOn = el('classMode') ? el('classMode').checked : false;

      if (!inside) {
        if (cw) cw.innerHTML = `<span class="warn">Outside selected province:</span> <b>${currentProvince}</b>.`;
        if (classModeOn && blockOutsideProvince) {
          setStatus('Outside Province', '#ffd56a', null, 'Click inside the selected province boundary.');
          return;
        }
      } else {
        if (cw && cw.innerHTML.includes('Outside selected province')) cw.textContent = '';
      }
    }
  } catch (e) {
    // non-fatal
  }

  isEvaluating = true;

  if (!marker) {
    marker = L.circleMarker(latlng, {radius: 8, color:'#ffffff', weight:2, fillColor:'#5dd6ff', fillOpacity:0.9}).addTo(map);
  } else {
    marker.setLatLng(latlng);
  }

  setStatus('Evaluating…', '#999', null, 'Fetching elevation + OSM features (roads/rivers).');
  setKPI('kSlope', null);
  setKPI('kElev', null);
  setKPI('kRiver', null);
  setKPI('kRoad', null);

  const z = Math.max(11, Math.min(14, map.getZoom())); // stable sampling zoom
  try {
    // 1) Slope + elev from Terrarium
    const {slopeDeg, elev} = await getSlopeDegrees(latlng.lat, latlng.lng, z);

    // 2) Distances from OSM
    const {dRiver, dRoad, isWater, isWetland, isSeasonalWater} = await getDistancesToOSM(latlng.lat, latlng.lng);
    const excludeWetlands = el('excludeWetlands') ? el('excludeWetlands').checked : false;
    // Fallback containment check for very large water bodies (lakes/seas) using Overpass is_in
    let inWaterArea = false, inWetlandArea = false, seasonalArea = false;
    try {
      const isin = await overpassIsInWaterWetland(latlng.lat, latlng.lng);
      inWaterArea = !!isin.inWater;
      inWetlandArea = !!isin.inWetland;
      seasonalArea = !!isin.seasonal;
    } catch (e) {}
    const finalIsWater = isWater || inWaterArea;
    const finalIsWetland = isWetland || inWetlandArea;
    const finalSeasonal = isSeasonalWater || seasonalArea;


    // Hard rule: water bodies are not suitable for siting.
// Wetlands are optional exclusion (teaching toggle).
    const seasonalNote = finalSeasonal ? ' Seasonal water body (intermittent=yes).' : '';
    if (finalIsWater) {
      setKPI('kSlope', slopeDeg.toFixed(1), '°');
      setKPI('kElev', elev.toFixed(0), ' m');
      setKPI('kRiver', dRiver === null ? 'n/a' : dRiver.toFixed(0), dRiver === null ? '' : ' m');
      setKPI('kRoad', dRoad === null ? 'n/a' : dRoad.toFixed(0), dRoad === null ? '' : ' m');
      setStatus('NOT SUITABLE (WATER)', '#ff6d8f', 0, `Clicked inside a mapped water body (lake/river/reservoir/sea) in OSM (polygon or area containment).${seasonalNote}`);
      return;
    }
    if (excludeWetlands && finalIsWetland) {
      setKPI('kSlope', slopeDeg.toFixed(1), '°');
      setKPI('kElev', elev.toFixed(0), ' m');
      setKPI('kRiver', dRiver === null ? 'n/a' : dRiver.toFixed(0), dRiver === null ? '' : ' m');
      setKPI('kRoad', dRoad === null ? 'n/a' : dRoad.toFixed(0), dRoad === null ? '' : ' m');
      setStatus('NOT SUITABLE (WETLAND)', '#ff6d8f', 0, `Clicked inside natural=wetland area (OSM).${seasonalNote}`);
      return;
    }

    // show KPIs
    setKPI('kSlope', slopeDeg.toFixed(1), '°');
    setKPI('kElev', elev.toFixed(0), ' m');
    setKPI('kRiver', dRiver === null ? 'n/a' : dRiver.toFixed(0), dRiver === null ? '' : ' m');
    setKPI('kRoad', dRoad === null ? 'n/a' : dRoad.toFixed(0), dRoad === null ? '' : ' m');

    // 3) Weighted scoring
    const wSlope = parseFloat(sliders.wSlope.value) / 100;
    const wRiver = parseFloat(sliders.wRiver.value) / 100;
    const wRoad  = parseFloat(sliders.wRoad.value) / 100;
    const wSum = Math.max(1e-9, wSlope + wRiver + wRoad);

    const slopeMax = parseFloat(sliders.slopeMax.value);  // degrees
    const riverSafe = parseFloat(sliders.riverSafe.value); // meters
    const roadMax  = parseFloat(sliders.roadMax.value);    // meters

    const slopeRisk = clamp01(slopeDeg / slopeMax); // 0 good, 1 bad
    const riverRisk = (dRiver === null) ? 0.5 : clamp01((riverSafe - dRiver) / riverSafe); // closer than safe => risk up
    const roadRisk  = (dRoad === null)  ? 0.5 : clamp01(dRoad / roadMax); // farther than roadMax => risk up

    const risk = (wSlope*slopeRisk + wRiver*riverRisk + wRoad*roadRisk) / wSum;
    const suit = 1 - risk;

    const cls = classifySuitability(suit);

    const why = [
      `Slope risk: ${(slopeRisk*100).toFixed(0)}%`,
      `River risk: ${(riverRisk*100).toFixed(0)}%`,
      `Road access risk: ${(roadRisk*100).toFixed(0)}%`
    ].join(' • ');

    setStatus(cls.label, cls.dot, suit, why);

  } catch (e) {
    setStatus('Could not evaluate', '#ff8aa6', null, (e && e.message ? e.message : String(e)));
  } finally {
    isEvaluating = false;
    lastEvalTs = Date.now();
  }
}

/* =========================
   Map events
   ========================= */
map.on('click', async (e) => {
  const classModeOn = el('classMode') ? el('classMode').checked : false;
  const now = Date.now();
  if (classModeOn && (now - lastEvalTs) < CLASS_COOLDOWN_MS) {
    const wait = Math.ceil((CLASS_COOLDOWN_MS - (now - lastEvalTs)) / 1000);
    const cw = el('clipWarn');
    if (cw) cw.innerHTML = `<span class="warn">Class Mode:</span> wait ${wait}s before next evaluation.`;
    return;
  }
  await evaluatePoint(e.latlng);
});

// (Legacy) Laguna button hidden; kept for backwards compatibility
el('btnLaguna').addEventListener('click', () => {
  loadProvinceBoundary('Laguna');
});

el('btnExplain').addEventListener('click', () => {
  alert(
`How the score works (simple map algebra):

1) We estimate slope (°) from real elevation tiles.
2) We query OpenStreetMap for nearby rivers/creeks and roads, then compute distances.
3) We normalize each factor to a 0–1 “risk” score:
   - Slope risk = slope / max tolerable slope
   - River risk = (safe distance - dist_to_river) / safe distance (only risky when too close)
   - Road risk  = dist_to_road / max walkable distance (farther = worse)
4) Total suitability = 1 - weighted average of risks.

Change weights to reflect different planning priorities (safety vs access vs proximity to water).`
  );
});

// Provinces list (as commonly used in PH admin_level=4 OSM boundary relations)
const PROVINCES = [
  "Abra","Agusan del Norte","Agusan del Sur","Aklan","Albay","Antique","Apayao","Aurora","Basilan","Bataan","Batanes","Batangas",
  "Benguet","Biliran","Bohol","Bukidnon","Bulacan","Cagayan","Camarines Norte","Camarines Sur","Camiguin","Capiz","Catanduanes","Cavite",
  "Cebu","Cotabato","Davao de Oro","Davao del Norte","Davao del Sur","Davao Occidental","Davao Oriental","Dinagat Islands","Eastern Samar",
  "Guimaras","Ifugao","Ilocos Norte","Ilocos Sur","Iloilo","Isabela","Kalinga","La Union","Laguna","Lanao del Norte","Lanao del Sur","Leyte",
  "Maguindanao del Norte","Maguindanao del Sur","Marinduque","Masbate","Misamis Occidental","Misamis Oriental","Mountain Province",
  "Negros Occidental","Negros Oriental","Northern Samar","Nueva Ecija","Nueva Vizcaya","Occidental Mindoro","Oriental Mindoro",
  "Palawan","Pampanga","Pangasinan","Quezon","Quirino","Rizal","Romblon","Samar","Sarangani","Siquijor","Sorsogon",
  "South Cotabato","Southern Leyte","Sultan Kudarat","Sulu","Surigao del Norte","Surigao del Sur","Tarlac","Tawi-Tawi",
  "Zambales","Zamboanga del Norte","Zamboanga del Sur","Zamboanga Sibugay"
];

function populateProvinceSelect() {
  const sel = el('provinceSelect');
  sel.innerHTML = "";
  for (const p of PROVINCES) {
    const opt = document.createElement('option');
    opt.value = p;
    opt.textContent = p;
    sel.appendChild(opt);
  }
  sel.value = currentProvince;
  el('provName').textContent = currentProvince;

  sel.addEventListener('change', () => {
    loadProvinceBoundary(sel.value);
  });
}

el('btnProvince').addEventListener('click', () => {
  const sel = el('provinceSelect');
  loadProvinceBoundary(sel.value);
});

// On load: initialize provinces + load default boundary
(function init() {
  populateProvinceSelect();
  loadProvinceBoundary(currentProvince);
  invalidateMapSize();
  msg.innerHTML = 'Tap/click the map to evaluate a location.';
})();
</script>
</body>
</html>
